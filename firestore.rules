/**
 * @fileoverview Firestore Security Rules for MuseFlow Prototyping.
 *
 * Core Philosophy:
 * This ruleset prioritizes a secure user-ownership model, ensuring that users can only
 * manage their own data. It also allows public read access to music-related data
 * (Artists, Albums, Songs) while restricting write access to ensure data integrity.
 *
 * Data Structure:
 * - User profiles are stored under `/users/{userId}`, with `userId` matching the
 *   Firebase Auth UID.
 * - User-created playlists are stored under `/users/{userId}/playlists/{playlistId}`.
 * - Music-related data (artists, albums, songs) are stored in top-level collections:
 *   `/artists/{artistId}`, `/albums/{albumId}`, and `/songs/{songId}` respectively.
 * - Social interactions (likes and comments) are stored as subcollections of songs:
 *   `/songs/{songId}/likes/{likeId}` and `/songs/{songId}/comments/{commentId}`.
 *
 * Key Security Decisions:
 * - User listing is allowed for authenticated users to discover creators.
 * - Public read access is granted for artists, albums, and songs.
 * - Strict ownership is enforced for user profiles and playlists.
 * - Likes and comments are secured to ensure data integrity, with a user being allowed to create a like if they are authenticated.
 *
 * Denormalization for Authorization:
 * The rules rely on path-based authorization (`userId` in the path matching `request.auth.uid`)
 * to avoid costly `get()` calls. For example, playlist ownership is determined by the
 * `userId` in the path `/users/{userId}/playlists/{playlistId}`.
 *
 * Structural Segregation:
 * Public music data (artists, albums, songs) is stored in top-level collections, separate
 * from private user data (playlists), which is stored under `/users/{userId}`. This
 * simplifies access control and ensures that listing operations are efficient.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Verifies user authentication for protected resources.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the requested userId matches the authenticated user's UID.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Enforces user ownership for data access.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the requested userId matches the authenticated user's UID, and that the document exists.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Enforces user ownership for data access, and verifies document existence for updates/deletes.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Rules for the /artists/{artistId} collection.
     * @path /artists/{artistId}
     * @allow (get, list): Any user can read artist data.
     * @allow (create, update, delete): No one can modify artist data without custom authorization logic.
     * @deny (create, update, delete): Any unauthenticated user.
     * @principle Public read access with restricted writes.
     */
    match /artists/{artistId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Rules for the /albums/{albumId} collection.
     * @path /albums/{albumId}
     * @allow (get, list): Any user can read album data.
     * @allow (create, update, delete): No one can modify album data without custom authorization logic.
     * @deny (create, update, delete): Any unauthenticated user.
     * @principle Public read access with restricted writes.
     */
    match /albums/{albumId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Rules for the /songs/{songId} collection.
     * @path /songs/{songId}
     * @allow (get, list): Any user can read song data.
     * @allow (create, update, delete): No one can modify song data without custom authorization logic.
     * @deny (create, update, delete): Any unauthenticated user.
     * @principle Public read access with restricted writes.
     */
    match /songs/{songId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Rules for the /users/{userId} collection.
     * @path /users/{userId}
     * @allow (create): A user can create their own profile if the userId matches their auth UID.
     * @allow (get, update, delete): A user can only access their own profile.
     * @allow (list): Authenticated users can list other users to find creators.
     * @deny (get, update, delete): Any unauthenticated user, or a user trying to access another user's profile.
     * @principle Enforces document ownership for user profiles, while allowing discovery.
     */
    match /users/{userId} {
      allow get, update, delete: if isExistingOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow list: if isSignedIn();
    }

    /**
     * @description Rules for the /users/{userId}/playlists/{playlistId} collection.
     * @path /users/{userId}/playlists/{playlistId}
     * @allow (create, get, update, delete, list): A user can only manage their own playlists.
     * @deny (create, get, update, delete, list): Any unauthenticated user, or a user trying to access another user's playlists.
     * @principle Enforces document ownership for playlists.
     */
    match /users/{userId}/playlists/{playlistId} {
      allow get, list, update, delete: if isExistingOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
    }

    /**
     * @description Rules for the /songs/{songId}/likes/{likeId} collection.
     * @path /songs/{songId}/likes/{likeId}
     * @allow (create): A user can create a like if authenticated.
     * @allow (get, list): Any user can read likes for a song.
     * @allow (update, delete): No one can modify likes without custom authorization logic.
     * @deny (update, delete): Any unauthenticated user.
     * @principle Allows public read access for likes with restricted writes, must be an authenticated user to create.
     */
    match /songs/{songId}/likes/{likeId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if false;
    }

    /**
     * @description Rules for the /songs/{songId}/comments/{commentId} collection.
     * @path /songs/{songId}/comments/{commentId}
     * @allow (create): A user can create a comment if authenticated.
     * @allow (get, list): Any user can read comments for a song.
     * @allow (update, delete): No one can modify comments without custom authorization logic.
     * @deny (update, delete): Any unauthenticated user.
     * @principle Allows public read access for comments with restricted writes, must be an authenticated user to create.
     */
    match /songs/{songId}/comments/{commentId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if false;
    }
  }
}
